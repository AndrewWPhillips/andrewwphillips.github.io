---
title: "Unique package"
last_modified_at: 2025-03-16T03:26:02+10:00
excerpt: "The unique package may be more useful than you think, but it does have some gotchas"
toc: true
toc_sticky: true
categories: [standard library,unique,intern]
tags: [unique,library]
header:
  overlay_image: "/assets/images/unique.jpg"
  overlay_filter: 0.4
permalink: /blog/unique.html
---

# Unique

I described the `unique` package in my [Go 1.23](https://andrewwphillips.github.io/blog/go1p23.html#unique-package) post when it first became public.  Many gophers have dismissed it as pointless thinnking that maps or pointers can do the same thing, and some are not concerned with saving a bit of memory.  But I think they miss the point.

It's true that in many ways a `unique.Handle` is just a pointer, but it has several niceties such as avoiding memory leaks as I already discussed in [unique package](https://andrewwphillips.github.io/blog/go1p23.html#unique-package) and further elaborate below.

But primarily `unique` is about making your code faster by speeding up comparisons.  Memory savings are a secondary benefit.

<font size="+6">❝</font><font size="+3">[it's] about making your code faster</font><font size="+6">❞</font><br/>

I will give a realistic example of how it might be used.  Then I'll demonstrate the performance and other advantages. Then finally explain a few **gotchas**.

## Background

<!--****************************-->
<details markdown="1">
<summary>General</summary>
<br/>

**Handles**

To understand the point of interning let's first consider handles.  Handles are designed to provide a convenient or efficient way to deal with objects.  Efficiency is often a result of the handle being much smaller than the object to which it refers.

Here are some examples of what I consider handles in code.

* array index - an integer allowing access to an object
* pointer - a memory address that points to the object
* key into map - the key provides access to the object
* file name (path) - a string giving access to a file
* checksum/CRC/hash - a value derived from the object
* cryptographic hash - a hash where it's "impossible" to derive the object from the value

There are several properties of handles that may be useful:

1. comparable - comparing handles == comparing values
2. retrievable - can you get back the original value?
3. uniqueness - different values have different handles
4. derivable - you can derive the handle from the object (as opposed to searching for it)
<!-- 5. orderable - handle order (<, >, <=, >=) reflects the object order -->

Generally handles are comparable (support ==, !=) but not all types of handles have all the above properties.  For example:

* a cryptographic hash is not retrievable (which is what makes it useful)
* an array index is not derivable - to get the index given the value you must search the array
* a hash value is not unique - e.g. collisions in hash table lookups have to be catered for
* but a hash _is_ derivable - you can obtain the handle just from the object value

---
</details>
<!--****************************-->
<details markdown="1">
<summary>Go</summary>
<br/>

**History of Go Interning**

The Go standard library has used "interning" for various specific data types from its inception.

However, generics (go 1.18) made it possible to create an interning package that can be used with any comparable type.

The Go standard library has had a such a package, for internal use, since Go 1.20 (see https://github.com/golang/go/blob/release-branch.go1.20/src/internal/intern/intern.go).

<!-- TBD internal/intern uses and any problems? -->

This internal package was enhanced and made public as the `unique` package in Go 1.23.

(I believe that **internal/intern** was, _in turn_ based on https://github.com/go4org/intern.)

**Constant String "Interning"**

Since strings in Go are immutable the compiler can "intern" literal strings.  (It can be important to understand this when testing `unique` with strings.)

If you have multiple literals of the same string, they will all use the same memory for the characters.  The following calls to `unsafe.StringData()` will all return the same address.  (Note that `unsafe.StringData()` returns the address of the string's underlying `byte` array.)

```go
	const sConst = "abc"
	println(unsafe.StringData(sConst))
	println(unsafe.StringData(sConst[:1]))
	println(unsafe.StringData("abc"))
	println(unsafe.StringData("ab" + "c"))
```

Note that only compile time constants are interned.  Strings generated at run-time (as of Go 1.24) will be placed in a separate memory location even if they are the same as an existing string.  (Note that this does not apply to the above `"ab" + "c"` because it is a string constant evaluated at compile-time.)

---
</details>
<!--****************************-->
<br/>

## Why do we need it?

If we have a lot of identical objects (same type and value) we can use them in two ways:

* by value - use a copy wherever necessary
* by reference - pass around a pointer to each object

Using objects by value is great most of the time but can be inefficient when you have multiple instances of large objects.

Then, why not just use simple pointers?  (After all `unique.Handle` is essentially just a pointer.)

Well something needs to _own_ the object being pointed to.

Interning is useful when there is no clear "owner" of (large) identical objects, _or_ you don't want to attach ownership to anything in particular.

<font size="+6">❝</font><font size="+3">... useful when there is no clear "owner"</font><font size="+6">❞</font><br/>

The `unique` package provides a way (`unique.Make[T]()`) to identify duplicates and retain each unique value exactly once.  It returns a `unique.Handle[T]`, which allows you to later retrieve the value (using the `unique.Handle[T].Value()` method).

There are several advantages, which I discuss below.  A major one is that you can compare handles much more efficiently than comparing the objects themselves, especially if the objects are large, such as long strings.

## Example

As an example, consider a site that sells products where customers are given discount vouchers which can be applied to certain products.

### Using **string**

First, for comparison, we will store the vouchers as strings.  A `customer` has a list of vouchers (`[]string`) that they own.  A `product` has a "set" of available vouchers (`map[string]struct{}`) to allow fast lookup.

```go
type (
	product struct {
		ID        productID
		Price     Currency
		Available map[string]struct{}
	}

	customer struct {
		Name     string
		Vouchers []string
	}
)

// hasDiscount - do you get a discount on a product?
func hasDiscount(c customer, p product) bool {
    for _, v := range c.Vouchers {
        if _, found := p.Discount[v]; found {
            return true
        }
    }
    return false
}
```

This code works fine, but consider some further aspects of the scenario.

For security, all vouchers include encrypted data and are digitally signed making them long (and with the same length), say 26 characters.

There are thousands of different products many of which have the same available discount vouchers.

Furthermore, the sales department have been profligate in their distribution of vouchers.  Many customers have lots of vouchers.

The end result is that at any one time there are many duplicate vouchers in memory all using about 40 bytes.  (This assumes that voucher strings come from "external" sources such as a database, user entry, etc, and are not subject to string interning as explained in the [Background->Go](#background) section above.)

### Using **unique.Handle[string]**

Let's store vouchers as `unique` handles instead of `string`s.  Note that the code for `hasDiscount()` does not need to change.

```go
type (
	product struct {
		ID        productID
		Price     Currency
		Available map[unique.Handle[string]]struct{}
	}

	customer struct {
		Name     string
		Vouchers []unique.Handle[string]
	}
)
```

Now, every duplicate copy of a voucher only requires an extra 8 bytes (on 64-bit systems where a pointer is 8 bytes) instead of 40.  Moreover, since these strings will most likely be stored on the heap, this will reduce load on the garbage collector.

Better yet, the `hasDiscount()` function will run at least 3 times faster, due to faster map lookups.

Note: Just doing simple comparisons (rather than map lookups) is **more than 10 times faster** - see benchmarks below.
{: .notice--info }

## Advantages

### Saves Memory

The obvious advantage of interning is that it saves memory.  Personally, I don't think this is particularly important, since memory is cheap nowadays.

If you are coding in a memory-constrained environment and/or you have a lot of large duplicated objects it may be useful.

<!-- TBD map fallacy -->

### Saves Time

The main advantage is the speed of comparing handles.  Internally a `unique.Handle` is just a pointer (ie, 8 bytes) - it takes a single CPU instruction to compare them, whereas comparing something like 2 long strings (of the same length) would take a lot longer.  The thorough benchmarks of [Viktor Pakhuchyi](https://blog.stackademic.com/a-first-look-at-unique-pkg-in-go-1-23-6a43a2377b68) show that it is many times faster even for simple strings.

Of course, this is only useful if you do lots of comparisons.  If you need to _use_ the values (using `unique.Handle[T].Value()`) more than you compare them then it may be _detrimental_ to performance.

Here's my quick benchmark.  Comparing handles is more than 10 times faster than comparing 26 character strings.

```go
import (
	"crypto/rand"
	"testing"
	"unique"
)

func BenchmarkCompareUniqueHandles(b *testing.B) {
	h1 := unique.Make(rand.Text())
	h2 := unique.Make(rand.Text())
	for i := 0; i < b.N; i++ {
		_ = h1 == h2
	}
}
```
On my machine this shows that comparing handles takes less than 0.3 ns/op, whereas comparing the strings takes about 3 ns/op.

### Avoids Memory Leaks

One thing that failed to occur to me when I first read about `unique` is that there is no way to delete objects once they are interned.

This brings me to one of the coolest things about the package.  When the last handle to an interned object is garbage-collected, the interned object is automatically deleted.

Why is this useful?  I'll give a real-life example...

A scenario I encountered was where a lot of objects where distributed in many places - usually added to maps.  The problem was that these objects would over time not be needed anymore but there was no simple way to determine when nothing was using them in order to delete them.

This is a classic **memory leak** in Go.  It meant that more and more memory was needed and after days or weeks the system memory would be exhausted.

We tried various things like wait-groups and atomic counters but these made the code difficult to maintain.  Eventually we settled on running a regular cleanup is a separate go-routine to scan all the data structures to identify those no longer being used and delete them from the map(s).

Using `unique` to intern the objects (instead of storing them in maps), then storing the handles (instead of the map keys) means that the memory leak problem just goes away.  As soon as the last handle to an object is no longer referenced and then garbage collected the object is automatically deleted.

### Generic (Comparable Types)

Because `unique.Make()` is a generic function you can use it with any comparable type.

Of course, it only makes sense to use it with large types - ie, where comparing objects of the type is slower than comparing the handles.  For example, it makes no sense to intern `int`s.
{: .notice-warning} 

In the future, it might be useful if `unique` is enhanced to work with any type - eg with a `MakeFunc()` function.

```go
func MakeFunc[T any](value T, f func(left, right T) bool) Handle[T]
```
<!-- TBD check that this would work and be useful -->

### Avoids Data Races

A useful features is that `unique.Make()` and `unique.Handle[T].Value()` are safe for concurrent use.

Using another solution, such as pointers, to deduplicate values then you would need to protect their concurrent use with something like `sync.Mutex` or `sync.RWMutex`.

### String Cloning

A known issue with strings is that holding a reference to a substring of a large string will prevent the large string from being garbage-collected while the substring is in use.

The package avoids this problem for strings -- `unique.Make[string]()` will clone strings so that when a sub-string of a larger string is interned this does not prevent the larger string from being garbage collected.

Warning: The behaviour is incorrect before Go 1.23.2 - see [Issue 69370](https://github.com/golang/go/issues/69370)
{: .notice-warning}

The problem still exists if you intern other objects that are part of a larger objects - see below.
{: .notice-error}

## Gotchas

### GC Issues

Although the problem of substrings was addressed (`unique.Make()` clones strings as mentioned above), the problem can still occur when an interned object refers to part of a larger object on the heap.  This is demonstrated by the following:

```go
	a := new([8192]int) // create large array on the heap
	unique.Make(&a[42])
	runtime.AddCleanup(a, func(i int) { println("GC of a") }, 0)
	a = nil // ensure a is no longer referenced
	runtime.GC()
	time.Sleep(time.Second) // wait for GC to finish
	println("after GC")
```
The above code only prints "after GC".  However, if you comment out the call to `unique.Make()`, it first prints "GC of a".

### Serialization

When I first read about interning, I considered using it on a large server application.  This stores millions of objects (structs) in memory and interning would greatly speed up comparisons of these objects.

Moreover, the code changes were relatively simple, involving simply converting something like this:

```go
	type customer struct {
		Name     string
		Vouchers []unique.Handle[string]
	}
```

to this:

```go
	type customer struct {
		Name     string
		Vouchers []unique.Handle[string]
	}
```

But I soon discovered a problem.  These structs on occasion need to be serialised to disk, requiring them to be GOB-encoded.  Unfortunately, GOB encoding (or JSON, XML, YAML, etc) does not support `unique.Handle`s.  Storing then retrieving the values loses the data.

The problem is that encoding of `unique.Handle` is not supported.  For example is JSON it is encoded as `{}`.

<!-- TBD custom marshaling example code -->

It would be great if the JSON, GOB etc packages were enhanced to support encoding of `unique.Handle`.

### Shared Maps

On first use, I was surprised that the `intern` package works with "global" data structures.  (Internally, I believe it is a single global map of maps.)

Globals are usually indicative of a bad design.  I expected that each user of `unique` would create a container for their private use.

As it is, if different packages in the same program _intern_ values of the same type then they will be sharing the same "set" of values.  So if you intern strings you will be sharing strings with any packages of your import tree that also inter strings.

This is **not** really a problem unless you are analysing the performance or testing the internal behaviour of the `unique` package.  It may cause misleading results.

Of course, you can obtain your own private "set" of values by creating a new type.  For example use `type myString string`, in order todifferent container when you use `unique.Make(myString("abc"))`.
 
## Conclusion

The `unique` package has several cool features.  It can be used to save memory and even avoid memory leaks, and is especially useful for concurrent code being thread-safe.

However, the main advantage is that you can get large increases in the speed of comparisons, when the objects to be compared are large.

As mentioned above you should be aware of limitations such interning parts of large objects preventing them from being interned.  Also, there is no support for serialisation in JSON etc.

Hopefully, these limitations are addressed in a future release.
